You fixed some layout bits, but a few blocking issues are still in there. Here’s the short, surgical punch list with exact patches.

1) Status type & maps are still out of sync

You use "contact_completed" and "unresponsive" in filters/mutations, but they’re not in the EventRequest['status'] union or in statusColors/statusIcons. This will bite you at runtime (bad badge) and compile-time.

Patch:

// extend the union
status:
  | "new"
  | "followed_up"
  | "in_process"
  | "scheduled"
  | "completed"
  | "declined"
  | "contact_completed"
  | "unresponsive";

// extend the maps
const statusColors = {
  /* existing… */
  contact_completed: "bg-gradient-to-r from-blue-50 to-indigo-100 text-indigo-700 border border-indigo-200",
  unresponsive: "bg-gradient-to-r from-rose-50 to-rose-100 text-rose-700 border border-rose-200",
} as const;

const statusIcons = {
  /* existing… */
  contact_completed: Phone,
  unresponsive: AlertTriangle,
} as const;

2) You still have two queries for the same users endpoint

availableUsers and users both hit /api/users/for-assignments.

Patch:
	•	Delete const { data: availableUsers = [] } = useQuery({ …enabled:true }).
	•	Use the existing users everywhere (availableUsers?.map → users?.map).

3) NodeJS.Timeout in a browser component

Will cause TS issues without Node types.

Patch:

const [undoTimeouts, setUndoTimeouts] =
  useState<Record<string, ReturnType<typeof setTimeout>>>({});

4) You’re still mixing permission strings with constants

You call hasPermission(user, "EVENT_REQUESTS_EDIT") in a couple places.

Patch:

hasPermission(user, PERMISSIONS.MANAGE_EVENT_REQUESTS)

5) shadcn <Select> is still used like a native <select>

Any FormData reads (formData.get("…")) won’t see values from shadcn Select. This affects multiple forms (create, edit, complete-contact, details).

Quick safest fix: swap those to native <select> only in forms (you already did that in some places). For any remaining shadcn Select inside a <form>, mirror it with a hidden input:

// helper
const [prevHosted, setPrevHosted] = useState("no");
<Select value={prevHosted} onValueChange={setPrevHosted}>
  <SelectTrigger><SelectValue placeholder="Select…" /></SelectTrigger>
  <SelectContent>
    {previouslyHostedOptions.map(o => <SelectItem key={o.value} value={o.value}>{o.label}</SelectItem>)}
  </SelectContent>
</Select>
<input type="hidden" name="previouslyHosted" value={prevHosted} />

(Repeat for every shadcn Select whose value you later read from FormData.)

6) Unreachable tab (or unreachable content)

You still render <TabsContent value="followed_up"> but there’s no TabsTrigger for followed_up. Either delete that TabsContent or add a trigger and a filter path:

Add trigger + filter:

<TabsTrigger value="followed_up">Followed Up</TabsTrigger>

case "followed_up":
  return eventRequests.filter(r => r.status === "followed_up");

7) requestsEvents builds a date then ignores it

You parse eventDate but the return condition is simply req.status === "new" || !req.status.

Patch (simplify):

const requestsEvents = eventRequests.filter(r => r.status === "new" || !r.status);

8) window.innerWidth during render (SSR risk)

You read window.innerWidth inside pagination JSX. If you ever SSR, it’ll blow up.

Patch (minimal):

const [isMobile, setIsMobile] = useState(false);
useEffect(() => {
  const onResize = () => setIsMobile(window.innerWidth < 640);
  onResize();
  window.addEventListener("resize", onResize);
  return () => window.removeEventListener("resize", onResize);
}, []);
// then use isMobile ? 3 : 5

9) Two overlapping update mutations

You still have editMutation and updateMutation (and a bunch of other mutations) all PUTting to /api/event-requests/:id.

Recommendation (low risk, high clarity): consolidate to a single updateEventMutation and use it everywhere. If you don’t want to rip it now, at least ensure all places call the same one for flat field updates.

10) You still rely on lots of (request as any) fields that aren’t typed

E.g., driversNeeded, assignedDriverIds, assignedSpeakerIds, toolkitStatus, deliveryDestination, storageLocation, finalDeliveryMethod, sandwichType, etc. Keep the interface honest so you stop leaking any.

Patch (incremental):

type ToolkitStatus = "not_sent" | "sent" | "received_confirmed" | "not_needed";
type FinalDeliveryMethod = "direct_delivery" | "driver_delivery" | "pickup_by_recipient";

interface EventRequest {
  // existing…
  driversNeeded?: number;
  speakersNeeded?: number;
  assignedDriverIds?: string[];
  assignedSpeakerIds?: string[];
  toolkitStatus?: ToolkitStatus;
  deliveryDestination?: string;
  storageLocation?: string;
  finalDeliveryMethod?: FinalDeliveryMethod;
  sandwichType?: string;
  volunteerNotes?: string;
}


⸻

One focused question: do you want me to convert the remaining shadcn Selects inside forms to native <select> right now (fastest path to correct submissions), or keep shadcn and add the hidden-input mirroring pattern everywhere?